<!DOCTYPE html>
<html>
<head>
    <title>Emblem Vault SDK - Step by Step Guide</title>
    <style>
        input, select, button, textarea {
            padding: 10px;
            margin: 5px;
        }
        #tokenImage{
            max-width: 300px;
        }
        #contractSelectContainer {
            margin: 15px 0;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .step-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .step-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #userInputForm {
            display: none;
            border: 1px solid #ccc;
            padding: 15px;
            margin: 15px 0;
            background-color: #f9f9f9;
        }
        .form-group {
            margin-bottom: 10px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .required {
            color: red;
        }
    </style>
</head>
<body>
    <h1>Emblem Vault - Step by Step Guide</h1>
    <script src="./bundle.js"></script>
    <script>
        const sdk = new EmblemVaultSDK('demo'); // Instantiate SDK
        let defaultAccount, vaultBalance, vaultData;
        let contractTemplate = {};
        let curatedContracts = [];
        let selectedContract = null;
        
        // Load curated contracts when the page loads
        window.onload = async function() {
            try {
                curatedContracts = await sdk.fetchCuratedContracts(false);
                generateContractDropdown(curatedContracts);
                updateLogCallback('Loaded', curatedContracts.length + ' curated contracts');
            } catch (error) {
                updateLogCallback('Error loading contracts', error.message);
            }
        };
        
        // Generate dropdown for contract selection
        function generateContractDropdown(contracts) {
            const selectElement = document.getElementById('contractSelect');
            selectElement.innerHTML = ''; // Clear existing options
            
            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.text = 'Select a contract';
            selectElement.appendChild(defaultOption);
            
            // Add contract options
            contracts.forEach((contract, index) => {
                if (contract.mintable) { // Only show mintable contracts
                    const option = document.createElement('option');
                    option.value = index;
                    option.text = contract.name;
                    selectElement.appendChild(option);
                }
            });

            // Add change event listener
            selectElement.addEventListener('change', selectContract);
        }
        
        // Handle contract selection
        function selectContract() {
            const selectElement = document.getElementById('contractSelect');
            const selectedIndex = selectElement.value;
            
            if (selectedIndex === '') {
                updateLogCallback('Error', 'Please select a contract');
                document.getElementById('step1Button').disabled = true;
                return;
            }
            
            selectedContract = curatedContracts[selectedIndex];
            updateLogCallback('Selected contract', selectedContract.name);
            
            // Generate template using the contract's built-in method
            contractTemplate = selectedContract.generateCreateTemplate(selectedContract);
            updateLogCallback('Contract template generated', contractTemplate);
            
            // Function to populate template with account info
            async function populateTemplateWithAccountInfo() {
                if (!defaultAccount) { // Only load web3 if not already loaded
                    await sdk.loadWeb3(); // Can be any web3 provider
                    defaultAccount = await web3.eth.getAccounts().then(accounts => accounts[0]).catch(err=>console); // Minter's address
                    updateLogCallback('Loading default account from web3:', defaultAccount);
                }
                
                let chainId = Number(await web3.eth.net.getId());
                
                // populate the template
                contractTemplate.toAddress = defaultAccount;
                contractTemplate.fromAddress = defaultAccount;
                contractTemplate.chainId = chainId;
                updateLogCallback('Contract template fromAddress populated with default account:', contractTemplate.fromAddress);
                updateLogCallback('Contract template toAddress populated with default account:', contractTemplate.toAddress);
                updateLogCallback('Contract template populated with chainId:', contractTemplate.chainId);
                
                // Validate template after population
                validateContractTemplate();
            }
            
            // Call the function to populate the template
            populateTemplateWithAccountInfo();
            
            // Hide the user input form by default
            document.getElementById('userInputForm').style.display = 'none';
            
            // Check if this is an open collection that requires user input
            if (selectedContract.name === "EmblemOpen" || selectedContract.collectionType === "open") {
                // Show the user input form
                document.getElementById('userInputForm').style.display = 'block';
                
                // Update form fields with any existing values from the template
                if (contractTemplate.targetAsset) {
                    // Clear existing values first
                    document.getElementById('userInputName').value = '';
                    document.getElementById('userInputImage').value = '';
                    document.getElementById('userInputDescription').value = '';
                    document.getElementById('userInputOwnedImage').value = '';
                    
                    // Only set string values, not objects
                    if (typeof contractTemplate.targetAsset.name === 'string') {
                        document.getElementById('userInputName').value = contractTemplate.targetAsset.name;
                    }
                    
                    if (typeof contractTemplate.targetAsset.image === 'string') {
                        document.getElementById('userInputImage').value = contractTemplate.targetAsset.image;
                    }
                    
                    if (typeof contractTemplate.targetAsset.description === 'string') {
                        document.getElementById('userInputDescription').value = contractTemplate.targetAsset.description;
                    }
                    
                    if (typeof contractTemplate.targetAsset.ownedImage === 'string') {
                        document.getElementById('userInputOwnedImage').value = contractTemplate.targetAsset.ownedImage;
                    }
                }
            }
            
            // Check validation and enable Step 1 button if valid
            validateContractTemplate();
        }
        
        // Function to update template from form inputs
        async function updateTemplateFromForm() {
            if (!contractTemplate || !contractTemplate.targetAsset) return;
            
            // Get user input values
            const imageInput = document.getElementById('userInputImage').value? document.getElementById('userInputImage').value.trim(): null;
            if (imageInput) contractTemplate.targetAsset.image = imageInput;
            const ownedImage = !document.getElementById('userInputOwnedImage').value? null: document.getElementById('userInputOwnedImage').value.trim();
            if (ownedImage) contractTemplate.targetAsset.ownedImage = ownedImage;

            
            contractTemplate.targetAsset.name = document.getElementById('userInputName').value? document.getElementById('userInputName').value.trim(): null;
            contractTemplate.targetAsset.description = document.getElementById('userInputDescription').value? document.getElementById('userInputDescription').value.trim(): null;

            // Remove empty fields
            Object.keys(contractTemplate.targetAsset).forEach(key => {
                if (!contractTemplate.targetAsset[key] || 
                    contractTemplate.targetAsset[key] === "" || 
                    contractTemplate.targetAsset[key] === null || 
                    contractTemplate.targetAsset[key] === undefined) {
                    delete contractTemplate.targetAsset[key];
                }
            });
            // IMPORTANT TO REMOVE OPTIONAL OWNED IMAGE IF NOT PROVIDED
            !ownedImage? delete contractTemplate.targetAsset.ownedImage : contractTemplate.targetAsset.ownedImage = ownedImage;
            
            updateLogCallback('Contract template updated with target asset:', contractTemplate.targetAsset);
            
            // Validate the template after updating
            if (imageInput || ownedImage) {
                let validImage = await sdk.contentTypeReport(imageInput)
                let validOwnedImage = ownedImage ? await sdk.contentTypeReport(ownedImage) : null;
                if (!validImage.valid || ownedImage && !validOwnedImage.valid) {
                    document.getElementById('step1Button').disabled = true;
                    updateLogCallback('Contract template validation failed', 'Invalid image format');
                    return;
                } 
            }            
            validateContractTemplate();
        }
        
        function validateContractTemplate() {
            if (!contractTemplate || !contractTemplate.targetContract ||!selectedContract) {
                document.getElementById('step1Button').disabled = true;
                updateLogCallback('Contract template validation failed', 'Template or contract not initialized');
                return;
            }
            console.log('contractTemplate', contractTemplate);
            
            let validatedCtemplate = selectedContract.validateTemplate(contractTemplate);
            if (validatedCtemplate.valid) {
                document.getElementById('step1Button').disabled = false;
                updateLogCallback('Contract template validated successfully', JSON.stringify(validatedCtemplate.valid));
            } else {
                document.getElementById('step1Button').disabled = true;
                // Format errors for better readability - simple approach
                let errorText = '';
                try {
                    // Just get the first error for simplicity
                    if (validatedCtemplate.errors && validatedCtemplate.errors.length > 0) {
                        // Get the raw error text and strip ALL quotes and formatting
                        const rawError = validatedCtemplate.errors[0].toString();
                        errorText = rawError.replace(/['"]/g, '');
                    }
                } catch (e) {
                    errorText = 'Invalid template format';
                }
                updateLogCallback('Contract template validation failed', errorText);
            }
        }
        
        // Function to format object for logging
        function formatObjectForLog(obj) {
            if (!obj) return 'empty';
            
            // Create a simplified representation
            const formatted = {};
            Object.keys(obj).forEach(key => {
                if (typeof obj[key] === 'object' && obj[key] !== null) {
                    formatted[key] = 'object';
                } else {
                    formatted[key] = obj[key];
                }
            });
            
            return Object.entries(formatted)
                .map(([key, value]) => `${key}: ${value}`)
                .join(', ');
        }
        
        // Update log callback function
        function updateLogCallback(title, message) {
            let formattedMessage = message;
            
            // Format objects for better readability
            if (typeof message === 'object' && message !== null) {
                formattedMessage = formatObjectForLog(message);
            }
            
            const logElement = document.getElementById('log');
            logElement.innerHTML += `<div><strong>${title}:</strong> ${formattedMessage}</div>`;
            logElement.scrollTop = logElement.scrollHeight;
        }
    </script>

    <div id="contractSelectContainer">
        <h3>Step 0: Select a Contract</h3>
        <select id="contractSelect"></select>
    </div>

    <!-- User Input Form for Open Collections -->
    <div id="userInputForm">
        <h3>Enter Vault Details</h3>
        <div class="form-group">
            <label for="userInputName">Name <span class="required">*</span></label>
            <input type="text" id="userInputName" placeholder="Enter vault name" required onchange="updateTemplateFromForm()">
        </div>
        <div class="form-group">
            <label for="userInputImage">Image URL <span class="required">*</span></label>
            <input type="text" id="userInputImage" placeholder="Enter image URL" required onchange="updateTemplateFromForm()">
        </div>
        <div class="form-group">
            <label for="userInputDescription">Description</label>
            <textarea id="userInputDescription" placeholder="Enter description" rows="3" onchange="updateTemplateFromForm()"></textarea>
        </div>
        <div class="form-group">
            <label for="userInputOwnedImage">Owned Image URL (Optional)</label>
            <input type="text" id="userInputOwnedImage" placeholder="Enter owned image URL (only shown to owner)" onchange="updateTemplateFromForm()">
        </div>
    </div>

    <button id="step1Button" class="step-button" onclick="Step1()" disabled>Step 1 (Create Vault)</button>
    <button id="step2Button" class="step-button" onclick="Step2()" disabled>Step 2 (Refresh Vault)</button>
    <button id="step3Button" class="step-button" onclick="Step3()" disabled>Step 3 (Mint)</button>
    <button onclick="clearLog()">Clear Log</button>
    
    <script>
        async function Step1() {
            if (!vaultData) {
                // Validate required fields for open collections
                if (contractTemplate.targetContract.name === "EmblemOpen" || 
                    contractTemplate.targetContract.vaultCollectionType === "open" || 
                    contractTemplate.targetContract.collectionType === "open") {
                    
                    const nameInput = document.getElementById('userInputName').value;
                    const imageInput = document.getElementById('userInputImage').value;
                    
                    if (!nameInput || !imageInput) {
                        updateLogCallback("Error", "Name and Image URL are required for open collections");
                        return;
                    }
                    
                    // Update the template one last time to ensure latest values
                    updateTemplateFromForm();
                }
                
                // Create a vault
                updateLogCallback("Creating vault for contract", contractTemplate.targetContract.name);
                vaultData = await sdk.createCuratedVault(contractTemplate, updateLogCallback).catch(err=>console.log(err));
                if (!vaultData || vaultData.err) {
                    updateLogCallback("Error creating vault", vaultData ? vaultData.err : "Unknown error");
                    setTimeout(Step1, 1000); // should Back off and try again
                } else {
                    const depositAddress = vaultData.addresses.find(address => address.coin === 'TAP')?.address;
                    updateLogCallback("Vault created successfully", "Token ID: " + vaultData.tokenId);
                    updateLogCallback("Deposit Address", depositAddress);
                    document.getElementById('step1Button').disabled = true;
                    document.getElementById('step2Button').disabled = false;
                }                
            }
        }

        async function Step2() {            
            if (vaultData) {
                updateLogCallback("Refreshing balance for token ID", vaultData.tokenId);
                vaultBalance = await sdk.refreshBalance(vaultData.tokenId, updateLogCallback).catch(err=>console);  // Refresh the balance
                if (vaultBalance.length > 0) { // We have a balance!!
                    updateLogCallback('Balance refreshed', JSON.stringify(vaultBalance));
                    
                    // Check if the vault is mintable
                    updateLogCallback("Validating mintability for", contractTemplate.targetContract.name);
                    let contractObject = await sdk.fetchCuratedContractByName(contractTemplate.targetContract.name);
                    let mintable = contractObject.allowed(vaultBalance, contractObject);
                    
                    if (mintable) {
                        updateLogCallback("Vault is mintable", "Proceed to Step 3 to mint");
                        document.getElementById('step2Button').disabled = true;
                        document.getElementById('step3Button').disabled = false;
                    } else {
                        updateLogCallback("Vault is not mintable", "Please check balance requirements");
                        // Keep Step 2 button enabled so user can refresh balance again
                    }
                } else {
                    updateLogCallback('No balance found', 'Please deposit assets to the vault address');
                }
            }
        }

        async function Step3() {
            if (vaultBalance.length > 0) {
               performMint();
            } else {
                updateLogCallback("Error", "No balance found");
            }    
        }

        async function performMint() {
            if (vaultData.tokenId) {
                // Perform Mint steps
                updateLogCallback("Starting mint process for token ID", vaultData.tokenId);
                sdk.performMintChain(web3, vaultData.tokenId, contractTemplate.targetContract.name, updateLogCallback).then(result => {
                    updateLogCallback('Minting success',  'tokenId: ' + vaultData.tokenId);
                })
                .catch(error => {
                    updateLogCallback('Minting error', error.message);
                });
            } else {
                updateLogCallback("Error", "No token ID found");
            }    
        }

        function clearLog(){
            document.getElementById('log').innerHTML = '';
        }
    </script>
    <h3>Log Output:</h3>
    <pre id="log"></pre>
</body>
</html>
