<!DOCTYPE html>
<html>
<head>
    <title>Emblem Vault SDK - Step by Step Guide</title>
    <style>
        input, select, button, textarea {
            padding: 10px;
            margin: 5px;
        }
        #tokenImage{
            max-width: 300px;
        }
        #contractSelectContainer {
            margin: 15px 0;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .step-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .step-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #userInputForm {
            display: none;
            border: 1px solid #ccc;
            padding: 15px;
            margin: 15px 0;
            background-color: #f9f9f9;
        }
        .form-group {
            margin-bottom: 10px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .required {
            color: red;
        }
    </style>
</head>
<body>
    <h1>Emblem Vault - Step by Step Guide</h1>
    <script src="./bundle.js"></script>
    <script src="./bitcoinjs-lib.js"></script>
    <script>
        window.bitcoin = bitcoin;
        const sdk = new EmblemVaultSDK('demo'); // Instantiate SDK
        let vaultBalance, vaultData, defaultAccount;
        let mintTemplate = {};
        let curatedContracts = [];
        let selectedContract = null;
        
        // Set connected Account
        // Load curated contracts when the page loads
        window.onload = async function() {
            try {
                // defaultAccount = await sdk.getConnectedEthAccount();
                curatedContracts = await sdk.fetchCuratedContracts(false);
                generateContractDropdown(curatedContracts);
                updateLogCallback('Loaded', curatedContracts.length + ' curated contracts');
            } catch (error) {
                updateLogCallback('Error loading contracts', error.message);
            }
        };
        
        // Generate dropdown for contract selection
        function generateContractDropdown(contracts) {
            const selectElement = document.getElementById('contractSelect');
            selectElement.innerHTML = ''; // Clear existing options
            
            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.text = 'Select a contract';
            selectElement.appendChild(defaultOption);
            
            // Add contract options
            contracts.forEach((contract, index) => {
                if (contract.mintable) { // Only show mintable contracts
                    const option = document.createElement('option');
                    option.value = index;
                    option.text = contract.name;
                    selectElement.appendChild(option);
                }
            });

            // Add change event listener
            selectElement.addEventListener('change', selectContract);
        }
        
        // Handle contract selection
        async function selectContract() {
            const selectElement = document.getElementById('contractSelect');
            const selectedIndex = selectElement.value;
            
            if (selectedIndex === '') {
                updateLogCallback('Error', 'Please select a contract');
                document.getElementById('step1Button').disabled = true;
                return;
            }
            
            selectedContract = curatedContracts[selectedIndex];
            updateLogCallback('Selected contract', selectedContract.name);
            
            // Get mint template from contract
            mintTemplate = selectedContract.mintTemplate
            updateLogCallback('Mint template acquired', mintTemplate);
            
            // Function to populate template with account info
            async function populateTemplateWithAccountInfo() {
                if (!defaultAccount) { // Only load web3 if not already loaded
                    await sdk.loadWeb3(); // Can be any web3 provider
                    defaultAccount = (await sdk.getProvider("ethereum").eth.getAccounts())[0]; // Minter's address
                    updateLogCallback('Loading default account from web3:', defaultAccount);
                }
                
                let chainId = Number(await sdk.getProvider("ethereum").eth.net.getId());
                
                // populate the template
                mintTemplate.toAddress = defaultAccount;
                mintTemplate.fromAddress = defaultAccount;
                mintTemplate.chainId = chainId;
                updateLogCallback('Mint template fromAddress populated with default account:', mintTemplate.fromAddress);
                updateLogCallback('Mint template toAddress populated with default account:', mintTemplate.toAddress);
                updateLogCallback('Mint template populated with chainId:', mintTemplate.chainId);
                
                // Validate template after population
                await validateMintTemplate();
            }
            
            // Call the function to populate the template
            await populateTemplateWithAccountInfo();
            
            // Hide the user input form by default
            document.getElementById('userInputForm').style.display = 'none';
            document.getElementById('assetSelectContainer').style.display = 'none';
            
            // Check if this is an open collection that requires user input
            if (selectedContract.loadTypes.includes("detailed")) {
                // Show the user input form
                document.getElementById('userInputForm').style.display = 'block';
            } else if (selectedContract.loadTypes.includes("select")) {
                // Show the asset selection dropdown
                document.getElementById('assetSelectContainer').style.display = 'block';
                await loadAssetsForSelection();
            }
        }
        
        // Function to update template from form inputs
        async function updateTemplateFromForm() {
            if (!mintTemplate || !mintTemplate.targetAsset) return;
            
            // Get user input values
            if (document.getElementById('userInputName') && document.getElementById('userInputName').value){
                const nameInput = document.getElementById('userInputName').value? document.getElementById('userInputName').value.trim(): null;
                if (nameInput) mintTemplate.targetAsset.name = nameInput;
            }
            
            if (document.getElementById('userInputImage') && document.getElementById('userInputImage').value){
                const imageInput = document.getElementById('userInputImage').value? document.getElementById('userInputImage').value.trim(): null;
                if (imageInput) mintTemplate.targetAsset.image = imageInput;
            } 
            if (document.getElementById('userInputDescription') && document.getElementById('userInputDescription').value){
                const descriptionInput = document.getElementById('userInputDescription').value? document.getElementById('userInputDescription').value.trim(): null;
                if (descriptionInput) mintTemplate.targetAsset.description = descriptionInput;
            }
            updateLogCallback('Mint template updated with target asset:', mintTemplate.targetAsset);       
            await validateMintTemplate();
        }
        
        // Function to load assets for selection
        async function loadAssetsForSelection() {
            const assets = sdk.getAssetMetadata(selectedContract.name);
            const selectElement = document.getElementById('vaultAssetSelect');
            selectElement.innerHTML = ''; // Clear existing options
            
            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.text = 'Select an asset';
            selectElement.appendChild(defaultOption);
            
            // Add asset options
            assets.forEach((asset, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = asset.assetName;
                selectElement.appendChild(option);
            });
            
            // Store assets in window for later use
            window.assets = assets;
        }
        
        // Function to update template from selected asset
        async function updateTemplateFromSelectedAsset() {
            const selectElement = document.getElementById('vaultAssetSelect');
            const selectedIndex = selectElement.value;
            
            if (selectedIndex === '') {
                updateLogCallback('Error', 'Please select an asset');
                return;
            }
            
            const selectedAsset = window.assets[selectedIndex];
            
            // Update the template with the selected asset
            if (mintTemplate.targetAsset) {
                if (selectedAsset.assetName) mintTemplate.targetAsset.name = selectedAsset.assetName;
                if (selectedAsset.image) mintTemplate.targetAsset.image = selectedAsset.image;
                if (selectedAsset.description) mintTemplate.targetAsset.description = selectedAsset.description;
            }
            
            updateLogCallback('Mint template updated with selected asset:', mintTemplate.targetAsset);
            await validateMintTemplate();
        }
        
        async function validateMintTemplate() {
            if (!mintTemplate || !mintTemplate.targetContract ||!selectedContract) {
                document.getElementById('step1Button').disabled = true;
                updateLogCallback('Mint template validation failed', 'Template or contract not initialized');
                return;
            }
            console.log('mintTemplate', mintTemplate);
            
            selectedContract.validateTemplate(mintTemplate, (mintTemplateValidation) => {
                if (mintTemplateValidation.valid) {
                    document.getElementById('step1Button').disabled = false;
                    updateLogCallback('Mint template validated successfully', JSON.stringify(mintTemplateValidation.valid));
                } else {
                    document.getElementById('step1Button').disabled = true;
                    // Format errors for better readability - simple approach
                    let errorText = '';
                    try {
                        // Just get the first error for simplicity
                        if (mintTemplateValidation.errors && mintTemplateValidation.errors.length > 0) {
                            // Get the raw error text and strip ALL quotes and formatting
                            const rawError = mintTemplateValidation.errors[0].toString();
                            errorText = rawError.replace(/['"]/g, '');
                        }
                    } catch (e) {
                        errorText = 'Invalid template format';
                    }
                    updateLogCallback('Mint template validation failed', errorText);
                }
            });
            
        }
        
        // Function to format object for logging
        function formatObjectForLog(obj) {
            if (!obj) return 'empty';
            
            // Create a simplified representation
            const formatted = {};
            Object.keys(obj).forEach(key => {
                if (typeof obj[key] === 'object' && obj[key] !== null) {
                    formatted[key] = 'object';
                } else {
                    formatted[key] = obj[key];
                }
            });
            
            return Object.entries(formatted)
                .map(([key, value]) => `${key}: ${value}`)
                .join(', ');
        }
        
        // Update log callback function
        function updateLogCallback(title, message) {
            let formattedMessage = message;
            
            // Format objects for better readability
            if (typeof message === 'object' && message !== null) {
                formattedMessage = formatObjectForLog(message);
            }
            
            const logElement = document.getElementById('log');
            logElement.innerHTML += `<div><strong>${title}:</strong> ${formattedMessage}</div>`;
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        // Function to fetch metadata for an existing vault
        async function fetchExistingVault() {
            const tokenId = document.getElementById('existingVaultId').value.trim();
            if (!tokenId) {
                updateLogCallback('Error', 'Please enter a valid token ID');
                return;
            }
            
            try {
                updateLogCallback('Fetching metadata for token ID', tokenId);
                const metadata = await sdk.fetchMetadata(tokenId);
                
                if (metadata) {
                    vaultData = metadata;
                    updateLogCallback('Metadata fetched successfully', metadata);
                    
                    // Log all deposit addresses
                    if (metadata.addresses && metadata.addresses.length > 0) {
                        updateLogCallback('Available Deposit Addresses:', '');
                        metadata.addresses.forEach(addr => {
                            updateLogCallback(`${addr.coin} Address:`, addr.address);
                        });
                    }
                    
                    // Enable step 2 button
                    document.getElementById('step1Button').disabled = true;
                    document.getElementById('step2Button').disabled = false;
                    
                    // Find the contract for this vault
                    if (metadata.targetContract && metadata.targetContract.name) {
                        const contractName = metadata.targetContract.name;
                        const contract = await sdk.fetchCuratedContractByName(contractName);
                        if (contract) {
                            selectedContract = contract;
                            mintTemplate = { targetContract: { name: contractName } };
                            updateLogCallback('Found contract for vault', contractName);
                        }
                    }
                } else {
                    updateLogCallback('Error', 'No metadata found for this token ID');
                }
            } catch (error) {
                updateLogCallback('Error fetching metadata', error.message || 'Unknown error');
            }
        }
    </script>

    <div id="contractSelectContainer">
        <h3>Step 0: Select a Contract</h3>
        <select id="contractSelect"></select>
    </div>
    
    <!-- <div id="existingVaultContainer" style="margin: 15px 0; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9;">
        <h3>Or Load an Existing Vault</h3>
        <div class="form-group">
            <label for="existingVaultId">Enter Vault Token ID:</label>
            <input type="text" id="existingVaultId" placeholder="Enter token ID">
            <button onclick="fetchExistingVault()" class="step-button">Load Vault</button>
        </div>
    </div> -->

    <!-- User Input Form for Open Collections -->
    <div id="userInputForm">
        <h3>Enter Vault Details</h3>
        <div class="form-group">
            <label for="userInputName">Name <span class="required">*</span></label>
            <input type="text" id="userInputName" placeholder="Enter vault name" required onchange="updateTemplateFromForm()">
        </div>
        <div class="form-group">
            <label for="userInputImage">Image URL <span class="required">*</span></label>
            <input type="text" id="userInputImage" placeholder="Enter image URL" required onchange="updateTemplateFromForm()">
        </div>
        <div class="form-group">
            <label for="userInputDescription">Description</label>
            <textarea id="userInputDescription" placeholder="Enter description" rows="3" onchange="updateTemplateFromForm()"></textarea>
        </div>
    </div>

    <!-- Asset Selection Dropdown for Select Collections -->
    <div id="assetSelectContainer" style="display: none;">
        <h3>Select Asset</h3>
        <div class="form-group">
            <label for="vaultAssetSelect">Available Assets <span class="required">*</span></label>
            <select id="vaultAssetSelect" onchange="updateTemplateFromSelectedAsset()"></select>
        </div>
    </div>

    <button id="step1Button" class="step-button" onclick="Step1()" disabled>Step 1 (Create Vault)</button>
    <button id="step2Button" class="step-button" onclick="Step2()" disabled>Step 2 (Refresh Vault)</button>
    <button id="step3Button" class="step-button" onclick="Step3()" disabled>Step 3 (Mint)</button>
    <button onclick="clearLog()">Clear Log</button>
    
    <script>
        async function Step1() {
            if (!vaultData) {
                if (mintTemplate.targetContract.vaultCollectionType === "open") {
                    
                    const nameInput = document.getElementById('userInputName').value;
                    const imageInput = document.getElementById('userInputImage').value;
                    
                    if (!nameInput || !imageInput) {
                        updateLogCallback("Error", "Name and Image URL are required for open collections");
                        return;
                    }
                    
                    // Update the template one last time to ensure latest values
                    updateTemplateFromForm();
                }
                
                // Create a vault
                updateLogCallback("Creating vault for contract", mintTemplate.targetContract.name);
                vaultData = await sdk.createCuratedVault(mintTemplate, updateLogCallback).catch(err=>console.log(err));
                // disable and add timer to button
                document.getElementById('step1Button').disabled = true;
                document.getElementById('step1Button').textContent = "Creating...";
                if (!vaultData || vaultData.err) {
                    updateLogCallback("Error creating vault", vaultData ? vaultData.err : "Unknown error");
                    setTimeout(Step1, 1000); // should Back off and try again
                } else {
                    const depositAddress = vaultData.addresses.find(address => address.coin === 'TAP')?.address;
                    updateLogCallback("Vault created successfully", "Token ID: " + vaultData.tokenId);
                    
                    // Log all deposit addresses
                    updateLogCallback("Available Deposit Addresses:", "");
                    vaultData.addresses.forEach(addr => {
                        updateLogCallback(`${addr.coin} Address:`, addr.address);
                    });
                    
                    document.getElementById('step1Button').disabled = true;
                    document.getElementById('step2Button').disabled = false;
                }                
            }
        }

        async function Step2() {            
            if (vaultData) {
                updateLogCallback("Refreshing balance for token ID", vaultData.tokenId);
                vaultBalance = await sdk.refreshBalance(vaultData.tokenId, updateLogCallback).catch(err=>console);  // Refresh the balance
                if (vaultBalance.length > 0) { // We have a balance!!
                    updateLogCallback('Balance refreshed', JSON.stringify(vaultBalance));
                    
                    // Check if the vault is mintable
                    updateLogCallback("Validating mintability for", mintTemplate.targetContract.name);
                    let contractObject = await sdk.fetchCuratedContractByName(mintTemplate.targetContract.name);
                    let mintable = contractObject.allowed(vaultBalance, contractObject);
                    
                    if (mintable) {
                        updateLogCallback("Vault is mintable", "Proceed to Step 3 to mint");
                        document.getElementById('step2Button').disabled = true;
                        document.getElementById('step3Button').disabled = false;
                    } else {
                        updateLogCallback("Vault is not mintable", "Please check balance requirements");
                        // Keep Step 2 button enabled so user can refresh balance again
                    }
                } else {
                    updateLogCallback('No balance found', 'Please deposit assets to the vault address');
                }
            }
        }

        async function Step3() {
            if (vaultBalance.length > 0) {
               performMint();
            } else {
               updateLogCallback("Error", "No balance found");
            }    
        }

        async function performMint() {
            if (vaultData.tokenId) {
                // Perform Mint steps
                updateLogCallback("Starting mint process for token ID", vaultData.tokenId);
                sdk.performMintChain(web3, vaultData.tokenId, mintTemplate.targetContract.name, updateLogCallback).then(result => {
                    updateLogCallback('Minting success',  'tokenId: ' + vaultData.tokenId);
                })
                .catch(error => {
                    updateLogCallback('Minting error', error.message);
                });
            } else {
                updateLogCallback("Error", "No token ID found");
            }    
        }

        function clearLog(){
            document.getElementById('log').innerHTML = '';
        }
    </script>
    <h3>Log Output:</h3>
    <pre id="log"></pre>
</body>
</html>
